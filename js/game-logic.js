/**
 * @todo: удалить этот текст отсюда
 1.
 + Функция на вход принимает массив ответов пользователя;
 + Функция на вход принимает кол-во оставшихся жизней;

 +- Функция на выходе отдаёт кол-во набранных очков.

 ***
 2.
 + Правильный ответ: 100 очков;
 + Быстрый ответ: добавляется 50 очков;
 + Медленный ответ: снимается 50 очков;
 + За каждую оставшуюся к концу игры жизнь: дополнительные 50 очков.

 ***
 3.
 Начните решение с описания тестовых случаев. Например:

 + Если игрок ответил меньше, чем на 10 вопросов, то игра считается не пройденной и функция должна вернуть -1;
 + Если игрок ответил на все вопросы и не быстро, и не медленно, и у него остались все жизни, то функция должна вернуть 1150 очков;

 - Комбинируйте разные условия ответов и кол-ва жизней, чтобы описать максимальное кол-во вариантов.
 - Реализуйте работу функции и убедитесь, что все тесты проходят.


 ***
 4.
 Правила подсчёта очков в соответствии с Техническим Заданием:

   Правильный ответ: 100 очков;
   Быстрый ответ: добавляется 50 очков;
   Медленный ответ: снимается 50 очков;
   За каждую оставшуюся к концу игры жизнь: дополнительные 50 очков.
 */

/**
 * Подсчет очков.
 *
 * @param {Array} answers
 * @param {Number} lives
 * @return {Number}
 */
export const checkScores = (answers, lives) => {
  const LIVES_ON_GAME_START = 3;

  const answersTotal = answers.length;
  let answersSuccess = 0;
  let answersFast = 0;
  let answersSlow = 0;
  let totalScore = 0;

  answers.forEach((answer) => {
    if (!answer.success) {
      return;
    }
    answersSuccess++;

    // Столько стоит каждый правильный ответ
    totalScore += 100;

    // Быстрый ответ стоит на 50 оччков дороже...
    if (answer.time < 10) {
      totalScore += 50;
      answersFast++;
    }
    // ... а медленный - на 50 дешевле
    if (answer.time > 20) {
      totalScore -= 50;
      answersSlow++;
    }
  });

  // Каждая оставшаяся жизнь тоже добавляет по 50 очков
  totalScore += (lives * 50);

  // Ответил < 10 вопросов
  if (answersSuccess < 10) {
    return -1;
  }
  // Ответил на все вопросы и не быстро, и не медленно, и у него остались все жизни
  if (answersTotal === answersSuccess
    && (!answersFast && !answersSlow)
    && lives === LIVES_ON_GAME_START) {
    totalScore = 1150;
  }

  return totalScore;
};

/**
 @todo: удалить этот текст отсюда
 Похожим образом реализуйте работу функции создания таймера:

 + Функция на вход должна принимать время, в течение которого будет работать таймер;
 + Функция на выходе возвращает объект таймера;
 + При каждом обновлении таймера (вызов метода tick), время уменьшается на единицу;
 +- При достижении конца, таймер должен сообщить о том, что он закончен.
 */

/**
 * Заполучить таймер и объявить ему время выполнения!
 *
 * @param {Number} runTimeSeconds
 * @return {Timer}
 */
export const getTimer = (runTimeSeconds) => {
  /**
   * 1) Класс создаем здесь или что-то другое они требуют в задании здесь?
   * 2) Если ли смысл давать классу имя, если мы его так сразу кладем в переменную Timer ?
   * Может лучше просто const Timer = class {} вместо const Timer = class Timer {} ?
   * Или для дебага лучше как есть сейчас? (в call stack проще искать)
   */
  const Timer = class Timer {
    constructor(time) {
      this.time = time;
    }

    /**
     * 3) Как он тут должен сообщить о том, что он закончить?
     *  - Exception что ли кинуть или вызвать что? :)
     *  - вернуть -1?
     *  - ... ?
     */
    tick() {
      if (this.time <= 0) {
        throw new Error(`I'm done with this!`);
      }
      this.time--;
    }

    isDone() {
      return this.time < 1;
    }

    getTimeLeft() {
      return this.time;
    }
  };

  return new Timer(runTimeSeconds);
};

/**
 @todo: удалить этот текст отсюда
 Mock для ответа.

 Массив ответов должен хранить в себе данные об ответах пользователя на каждый вопрос по порядку —
 информацию об успешном или неуспешном ответе и времени, затраченном на ответ.
 */

/**
 * Нужен ли он тут? И вообще нужен ли он? Куда эту фикстуру лучше впихнуть, если нужен?
 *
 * Получить сгенерированный mock-объект ответа.
 *
 * @param {Boolean} success
 * @param {Number} time
 * @return {Object}
 */
export const getMockAnswer = (success, time) => {
  return {
    success,
    time
  };
};
